<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holo Signal Feed & Backtester</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    <!-- Font for code block (optional but nice) -->
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0d1117;
            --card-color: #161b22;
            --accent-color: #00bcd4; /* Cyan/Holo */
            --pulse-color: rgba(0, 188, 212, 0.2);
            --pnl-color-pos: #10b981;
            --pnl-color-neg: #ef4444;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Minimalist Visual Polish: Dynamic Background Pulses */
        .market-pulse-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 10% 10%, var(--pulse-color) 0%, transparent 15%),
                        radial-gradient(circle at 90% 90%, var(--pulse-color) 0%, transparent 15%);
            opacity: 0.05;
            animation: slowPulse 60s infinite alternate;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes slowPulse {
            0% { transform: scale(1.0); opacity: 0.05; }
            100% { transform: scale(1.1); opacity: 0.15; }
        }

        /* Micro-animation for new signals */
        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 4px var(--accent-color)); }
            50% { filter: drop-shadow(0 0 8px var(--accent-color)); }
        }
        .signal-item.is-new {
            animation: fadeIn 0.5s ease-out, subtleFlash 1.5s ease-out 1;
        }
        @keyframes subtleFlash {
            0% { background-color: rgba(0, 188, 212, 0.1); }
            100% { background-color: transparent; }
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Ghost Persona Styling */
        .oracle-ghost {
            font-size: 1.25rem;
            color: #4a5568;
            transition: color 0.3s;
        }
        .oracle-ghost-glowing {
            color: var(--accent-color);
            animation: glow 1s infinite alternate;
        }

        /* Micro-transitions for smoothness */
        .signal-item {
            transition: all 0.3s ease-in-out;
        }
        .signal-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 188, 212, 0.15);
        }

        /* Backtester Code Editor Styling */
        #strategy-code-input {
            min-height: 400px;
            font-family: 'Fira Code', monospace;
            background-color: #1e293b; /* Slate 800 */
            color: #a7f3d0; /* Emerald 200 for code */
            border: 1px solid #334155; /* Slate 700 */
            resize: none;
            padding: 1rem;
        }
        .tab-button.active {
            color: #00bcd4; /* Accent color */
            border-bottom: 3px solid #00bcd4;
        }
        
        .connect-btn-style {
            background-color: #f6851b; /* MetaMask Orange */
            transition: all 0.2s ease-in-out;
        }
        .connect-btn-style:hover {
            background-color: #f0b90b; /* Binance Yellow for contrast */
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.5);
        }

    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="market-pulse-bg"></div>

    <div class="relative z-10 max-w-7xl mx-auto">
        <header class="flex flex-col xl:flex-row justify-between items-center mb-8 pb-4 border-b border-gray-700">
            <div class="flex items-center space-x-6 mb-4 xl:mb-0">
                <!-- Tab Buttons for Client-side Routing -->
                <button onclick="showPage('signal-feed-page')" id="nav-feed" class="tab-button text-xl font-extrabold pb-1.5 transition-all active" >
                    Holo Signal Feed
                </button>
                <button onclick="showPage('backtester-page')" id="nav-backtester" class="tab-button text-lg font-semibold text-gray-400 hover:text-white pb-1.5 transition-all">
                    Strategy Backtester
                </button>
            </div>
            
            <div class="flex flex-wrap items-center justify-center sm:justify-end space-x-4">
                <!-- MetaMask Connection Status/Button -->
                <div id="wallet-status-area" class="flex items-center space-x-2 p-2 bg-gray-800 rounded-lg border border-gray-700 shadow-lg min-w-[150px]">
                    <span id="account-display-short" class="text-sm font-mono text-cyan-400 truncate max-w-[100px]">
                        Not Connected
                    </span>
                    <button id="connect-button" 
                            class="connect-btn-style text-white font-semibold px-3 py-1 text-xs rounded-lg disabled:opacity-50"
                            onclick="connectWallet()" disabled>
                        Connect
                    </button>
                </div>

                 <!-- Tiny gas tracker -->
                 <span id="gas-tracker" class="text-sm font-mono px-3 py-1 rounded-full bg-gray-800 text-yellow-400 transition-colors duration-500 shadow-inner">
                    Gas: 22 Gwei
                </span>
                
                <!-- Auto-refresh toggle -->
                <label class="inline-flex items-center cursor-pointer">
                    <span class="mr-2 text-gray-300 text-sm">Stream</span>
                    <input type="checkbox" id="autoRefreshToggle" checked class="sr-only peer">
                    <div class="relative w-11 h-6 bg-gray-700 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-cyan-800 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-cyan-600"></div>
                </label>
            </div>
        </header>

        <!-- Python Strategy Backtester Page (For Investors/Creators) -->
        <div id="backtester-page" class="hidden">
            <h2 class="text-3xl font-bold mb-6 text-cyan-400">
                <svg class="w-8 h-8 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path></svg>
                Python Strategy Code Snippet Backtester
            </h2>

            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

                <!-- Main Code Input Area (2/3 width) -->
                <div class="lg:col-span-2 space-y-4">
                    <label for="strategy-code-input" class="block text-gray-300 font-semibold text-lg">Enter Your Algorithmic Strategy Logic</label>
                    <textarea id="strategy-code-input" class="w-full rounded-lg text-sm transition-colors focus:ring-cyan-500 focus:border-cyan-500 shadow-inner" placeholder="# Example: Use a simple moving average crossover for entry signals.
# This simulation assumes 'df' is your price/volume dataframe.

# Define variables
SHORT_WINDOW = 10
LONG_WINDOW = 30

# Calculate MAs
df['short_ma'] = df['price'].rolling(window=SHORT_WINDOW).mean()
df['long_ma'] = df['price'].rolling(window=LONG_WINDOW).mean()

# Generate Signal: Buy when short crosses above long
signal = (df['short_ma'].shift(1) < df['long_ma'].shift(1)) & (df['short_ma'] > df['long_ma'])

# Generate Signal: Sell when short crosses below long
exit_signal = (df['short_ma'].shift(1) > df['long_ma'].shift(1)) & (df['short_ma'] < df['long_ma'])

# Execute trade simulation based on signal
if signal.any():
    execute_trade('BUY', '1 ETH', 'MA_CROSS')

# Backtest duration: 30 days
# Initial capital: 10,000 USD
# Slippage tolerance: 0.001
"
></textarea>

                    <div class="flex justify-between items-center">
                        <span id="backtester-message" class="text-sm text-gray-400">
                            Code length: <span id="backtest-code-length">0</span> / 50 min.
                        </span>

                        <button onclick="runBacktest()" id="run-backtest-btn" class="px-6 py-3 bg-gradient-to-r from-teal-500 to-green-600 text-white font-bold rounded-xl shadow-lg hover:from-teal-400 hover:to-green-500 transition-all active:shadow-none active:scale-95 flex items-center space-x-2 disabled:opacity-50">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                            <span>Run Simulated Backtest</span>
                        </button>
                    </div>

                    <div id="backtest-results" class="mt-6 hidden">
                        <!-- Simulated results card will be injected here -->
                    </div>
                </div>

                <!-- Placeholders and Contextual Hints (1/3 width) -->
                <div class="lg:col-span-1 space-y-6">

                    <!-- Mint Signal Placeholder (UPDATED WITH LIVE ADDRESS) -->
                    <div class="p-6 bg-gray-800 rounded-xl border border-gray-700 shadow-xl">
                        <h3 class="text-xl font-semibold mb-2 text-purple-400 flex items-center space-x-2">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                            Minter/Creator Authorization
                        </h3>
                        <p class="text-gray-400 text-sm">Only the designated Minter can officially mint strategies as tradable signals.</p>
                        <button id="mint-signal-button" class="mt-3 w-full py-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-white font-semibold transition-colors shadow-md disabled:opacity-50" onclick="mintStrategy('Backtest-Simulated')">
                            Mint Signal Contract (Check Permissions)
                        </button>
                        <div class="mt-4 text-xs break-all p-2 bg-gray-700 rounded-md">
                            <span class="font-semibold text-white block mb-1">DESIGNATED MINTER:</span>
                            <code id="minter-address-display" class="text-cyan-300">0xb5A2E634b73785fdFB2e36c24D7E79f8ac3ddBb2</code>
                        </div>
                        <div class="mt-2 text-xs break-all p-2 bg-gray-700 rounded-md">
                            <span class="font-semibold text-white block mb-1">YOUR CONNECTED WALLET (Creator ID):</span>
                            <code id="mint-wallet-display" class="text-red-300">N/A (Connect Wallet)</code>
                        </div>
                    </div>

                    <!-- Leaderboard Placeholder -->
                    <div class="p-6 bg-gray-800 rounded-xl border border-gray-700 shadow-xl">
                        <h3 class="text-xl font-semibold mb-2 text-yellow-400 flex items-center space-x-2">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c1.657 0 3 .895 3 2s-1.343 2-3 2h-1v5m1-7h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            Top 5 Leaderboard Signals (Investor View)
                        </h3>
                        <ul class="text-gray-300 space-y-2 text-sm">
                            <li class="flex justify-between border-b border-gray-700/50 pb-1"><span>#1 MA Cross (By 0xCFD...) </span><span class="text-green-400">SR 2.51</span></li>
                            <li class="flex justify-between border-b border-gray-700/50 pb-1"><span>#2 Volatility Arb (By 0xBB8...)</span><span class="text-green-400">SR 1.98</span></li>
                            <li class="flex justify-between border-b border-gray-700/50 pb-1"><span>#3 RSI Divergence (By 0xEEE...)</span><span class="text-yellow-400">SR 1.45</span></li>
                            <li class="flex justify-between border-b border-gray-700/50 pb-1"><span>#4 Order Book Skew (By 0x123...)</span><span class="text-red-400">SR 0.88</span></li>
                            <li class="flex justify-between pb-1"><span>#5 Delta Neutral (By 0xABC...)</span><span class="text-red-400">SR 0.22</span></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Signal Feed Page (Main Content - For Collectors) -->
        <div id="signal-feed-page">
            <h2 class="text-3xl font-bold mb-6 text-cyan-400">
                 <svg class="w-8 h-8 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                Real-Time Volatility Arbitrage Stream
            </h2>
            <p class="text-gray-400 mb-6">Signals are minted by verified creators. Check the Creator ID for provenance before trading.</p>

            <div id="signal-feed" class="space-y-4">
                <!-- Signal items will be injected here by JavaScript -->
            </div>
        </div>

        <!-- Pop-up message box for confirmation -->
        <div id="message-box" class="fixed bottom-4 right-4 bg-gray-900 text-white p-3 rounded-xl shadow-2xl border border-cyan-500 transition-opacity duration-300 opacity-0 pointer-events-none text-sm z-50">
            <!-- Messages injected here -->
        </div>
    </div>

    <!-- Hidden Audio element for TTS playback -->
    <audio id="audio-player" class="hidden"></audio>

    <script>
        // --- Global Variables and Constants ---
        const MINTER_ADDRESS = '0xb5A2E634b73785fdFB2e36c24D7E79f8ac3ddBb2'.toLowerCase(); // Defined Minter/Creator
        
        const SIGNAL_FEED = document.getElementById('signal-feed');
        const MESSAGE_BOX = document.getElementById('message-box');
        const AUTO_REFRESH_TOGGLE = document.getElementById('autoRefreshToggle');
        const GAS_TRACKER = document.getElementById('gas-tracker');
        const AUDIO_PLAYER = document.getElementById('audio-player');

        const BACKTEST_CODE_INPUT = document.getElementById('strategy-code-input');
        const BACKTEST_CODE_LENGTH_SPAN = document.getElementById('backtest-code-length');
        const BACKTEST_RESULTS_DIV = document.getElementById('backtest-results');
        const RUN_BACKTEST_BTN = document.getElementById('run-backtest-btn');
        
        // MetaMask Elements
        const CONNECT_BUTTON = document.getElementById('connect-button');
        const ACCOUNT_DISPLAY_SHORT = document.getElementById('account-display-short');
        const MINT_WALLET_DISPLAY = document.getElementById('mint-wallet-display');
        const MINTER_ADDRESS_DISPLAY = document.getElementById('minter-address-display');
        const MINT_SIGNAL_BUTTON = document.getElementById('mint-signal-button');
        
        const MAX_SIGNALS = 15;
        const REFRESH_INTERVAL = 3000; // 3 seconds
        const MIN_CODE_LENGTH = 50; 
        
        let signalTimer;
        let isRefreshing = true;
        let connectedAccount = null; 
        
        const API_KEY = ""; // Key left empty for runtime environment to populate
        const TTS_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${API_KEY}`;
        const VOICE_NAMES = [
            "Kore", "Charon", "Orus", "Iapetus", "Algieba", "Rasalgethi", "Alnilam", "Gacrux", "Pulcherrima"
        ];
        
        // State
        let signals = [];
        let bookmarks = JSON.parse(localStorage.getItem('signalBookmarks') || '{}');
        
        // --- Initialization: Set the fixed minter address display ---
        MINTER_ADDRESS_DISPLAY.textContent = MINTER_ADDRESS;


        // --- Utility Functions ---
        
        const formatAddress = (address) => {
            if (!address) return 'N/A';
            return `${address.substring(0, 6)}...${address.slice(-4)}`;
        };

        const showMessageBox = (message, type = 'info') => {
            MESSAGE_BOX.textContent = message;
            MESSAGE_BOX.classList.remove('opacity-0', 'border-cyan-500', 'border-red-500', 'border-yellow-500', 'pointer-events-none');
            MESSAGE_BOX.classList.add('opacity-100');

            if (type === 'error') {
                MESSAGE_BOX.classList.add('border-red-500');
            } else if (type === 'warning') {
                MESSAGE_BOX.classList.add('border-yellow-500');
            } else {
                MESSAGE_BOX.classList.add('border-cyan-500');
            }

            setTimeout(() => {
                MESSAGE_BOX.classList.remove('opacity-100');
                MESSAGE_BOX.classList.add('opacity-0', 'pointer-events-none');
            }, 3000);
        };
        
        async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) return response;
                    if (response.status === 429 && i < retries - 1) { 
                        await new Promise(resolve => setTimeout(resolve, delay * (2 ** i)));
                    } else {
                        throw new Error(`API error: ${response.statusText}`);
                    }
                } catch (error) {
                    if (i === retries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, delay * (2 ** i)));
                }
            }
        }

        // --- MetaMask Wallet Logic ---
        
        // Determines if the connected account is the designated minter
        function isMinter(account) {
            if (!account) return false;
            return account.toLowerCase() === MINTER_ADDRESS;
        }

        function updateWalletUI(accounts, chainId) {
            const currentAccount = accounts.length > 0 ? accounts[0].toLowerCase() : null;
            
            if (currentAccount) {
                connectedAccount = currentAccount;
                ACCOUNT_DISPLAY_SHORT.textContent = formatAddress(connectedAccount);
                CONNECT_BUTTON.textContent = 'Connected';
                CONNECT_BUTTON.disabled = true;
                CONNECT_BUTTON.style.backgroundColor = '#10b981'; // Green for connected

                // Update Minting Permissions UI
                MINT_WALLET_DISPLAY.textContent = connectedAccount;
                const minterMatch = isMinter(connectedAccount);

                MINT_WALLET_DISPLAY.classList.remove('text-red-300', 'text-yellow-300', 'text-green-300');
                
                if (minterMatch) {
                    MINT_WALLET_DISPLAY.classList.add('text-green-300');
                    MINT_SIGNAL_BUTTON.disabled = false;
                    MINT_SIGNAL_BUTTON.textContent = 'Authorize Mint Transaction';
                } else {
                    MINT_WALLET_DISPLAY.classList.add('text-yellow-300');
                    MINT_SIGNAL_BUTTON.disabled = true;
                    MINT_SIGNAL_BUTTON.textContent = 'Minting Not Authorized (Wrong Wallet)';
                }
                
            } else {
                // Wallet disconnected/locked
                connectedAccount = null;
                ACCOUNT_DISPLAY_SHORT.textContent = 'Not Connected';
                CONNECT_BUTTON.textContent = 'Connect';
                CONNECT_BUTTON.disabled = false;
                CONNECT_BUTTON.style.backgroundColor = '#f6851b';
                
                MINT_WALLET_DISPLAY.textContent = 'N/A (Connect Wallet)';
                MINT_WALLET_DISPLAY.classList.remove('text-green-300', 'text-yellow-300');
                MINT_WALLET_DISPLAY.classList.add('text-red-300');
                MINT_SIGNAL_BUTTON.disabled = true;
                MINT_SIGNAL_BUTTON.textContent = 'Connect Wallet to Mint';
            }
            
            // Re-render the feed to update Mint button state for collectors
            renderFeed(); 
        }
        
        function checkMetaMaskAvailability() {
            if (typeof window.ethereum === 'undefined') {
                showMessageBox('MetaMask not found. Install it to mint signals.', 'error');
                CONNECT_BUTTON.disabled = true;
                CONNECT_BUTTON.textContent = 'No MetaMask';
                MINT_SIGNAL_BUTTON.disabled = true;
                MINT_SIGNAL_BUTTON.textContent = 'No MetaMask';
                return false;
            }
            CONNECT_BUTTON.disabled = false;
            return true;
        }

        async function getInitialState() {
            if (!checkMetaMaskAvailability()) return;
            
            try {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                updateWalletUI(accounts, chainId);
            } catch (error) {
                console.error("Error checking initial state:", error);
                showMessageBox('Error retrieving wallet state.', 'error');
            }
        }

        window.connectWallet = async function() {
            if (!window.ethereum) return;

            CONNECT_BUTTON.disabled = true;
            CONNECT_BUTTON.textContent = 'Connecting...';

            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                updateWalletUI(accounts, chainId);
            } catch (error) {
                console.error("User rejected connection or connection failed:", error);
                showMessageBox('Connection request denied by user.', 'warning');
                CONNECT_BUTTON.disabled = false;
                CONNECT_BUTTON.textContent = 'Connect';
                CONNECT_BUTTON.style.backgroundColor = '#f6851b';
            }
        }

        function setupListeners() {
            if (!window.ethereum) return;

            window.ethereum.on('accountsChanged', (accounts) => {
                showMessageBox('Account changed! Updating UI...', 'info');
                window.ethereum.request({ method: 'eth_chainId' }).then(chainId => {
                    updateWalletUI(accounts, chainId);
                });
            });

            window.ethereum.on('chainChanged', (chainId) => {
                showMessageBox('Network changed! Updating UI...', 'info');
                window.ethereum.request({ method: 'eth_accounts' }).then(accounts => {
                    updateWalletUI(accounts, chainId);
                });
            });
        }
        
        // --- Strategy and Signal Logic (Previous DApp functions) ---
        // TTS Utility functions are omitted for brevity but assumed to be present.
        
        // Backtester Functions
        const simulateBacktest = (codeLength) => {
            const complexityMultiplier = 1 + (codeLength / 500) * 0.5; 
            
            let pnl = parseFloat(((Math.random() * 0.4 - 0.15) * complexityMultiplier * 100).toFixed(2));
            if (pnl > 0) pnl += 5; 
            pnl = parseFloat(pnl.toFixed(2));

            const sharpe = parseFloat(Math.max(0.2, (0.5 + Math.random() * 2.5) * complexityMultiplier)).toFixed(2);
            
            let drawdown = parseFloat((15 + Math.random() * 25)).toFixed(2); 
            if (pnl > 0) {
                drawdown = parseFloat(Math.max(5, drawdown / (1 + pnl / 10))).toFixed(2);
            }

            return { pnl: pnl, sharpe: parseFloat(sharpe), drawdown: parseFloat(drawdown) };
        };

        const renderBacktestResults = (results) => {
            const isPositive = results.pnl >= 0;
            const pnlColor = isPositive ? 'text-green-400' : 'text-red-400';
            const sharpeColor = results.sharpe > 1.0 ? 'text-cyan-400' : 'text-yellow-400';
            const drawdownColor = results.drawdown < 20 ? 'text-green-400' : 'text-red-400';
            
            // The Creator ID is the connected wallet
            const creatorId = connectedAccount ? formatAddress(connectedAccount) : 'N/A';
            const creatorFullId = connectedAccount || 'N/A';


            const StatCard = ({ label, value, color }) => `
                <div class="p-4 rounded-lg flex flex-col items-center bg-gray-700/50 border border-gray-600">
                    <p class="text-sm font-medium mb-1 text-gray-400">${label}</p>
                    <p class="text-2xl font-extrabold ${color}">${value}</p>
                </div>
            `;
            
            const mintBtnDisabled = MINT_SIGNAL_BUTTON.disabled ? 'disabled' : '';

            return `
                <div class="p-6 bg-gray-800 rounded-xl shadow-2xl border border-cyan-700/50">
                    <h3 class="text-xl font-bold mb-4 flex items-center gap-2 text-white">
                        <svg class="w-6 h-6 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.204A9 9 0 0121 12a9 9 0 01-18 0 9 9 0 019-8.796z"></path></svg>
                        Backtest Complete! (For Investor Review)
                    </h3>
                    
                    <div class="mb-4 p-3 bg-gray-700 rounded-lg text-sm">
                        <p class="text-gray-400 mb-1">Creator ID: <span class="font-mono text-cyan-300">${creatorId}</span></p>
                        <a href="#" onclick="showMessageBox('Simulating full Creator Profile for ${creatorId}', 'info'); return false;" class="text-purple-400 hover:text-purple-300 text-xs underline">
                            View Full Creator Profile (Simulated)
                        </a>
                    </div>
                    
                    <div class="grid grid-cols-3 gap-4">
                        ${StatCard({ label: "P&L %", value: `${results.pnl}%`, color: pnlColor })}
                        ${StatCard({ label: "Sharpe Ratio", value: results.sharpe, color: sharpeColor })}
                        ${StatCard({ label: "Max Drawdown", value: `${results.drawdown}%`, color: drawdownColor })}
                    </div>
                    <button class="mt-4 w-full py-2 bg-gradient-to-r from-purple-600 to-pink-500 text-white font-bold rounded-lg shadow-md hover:from-purple-700 hover:to-pink-600 transition-all ${mintBtnDisabled ? 'opacity-50 cursor-not-allowed' : ''}" onclick="mintStrategy('Backtest-${Math.random().toString(36).substring(2, 8)}')">
                        Mint Strategy Signal (Minter Only)
                    </button>
                    ${mintBtnDisabled ? `<p class="text-xs text-center text-red-400 mt-2">Cannot mint. Your connected wallet is not the designated minter.</p>` : ''}
                </div>
            `;
        };
        
        const runBacktest = () => {
            const code = BACKTEST_CODE_INPUT.value;
            if (code.length < MIN_CODE_LENGTH) {
                showMessageBox(`Code too short! Minimum ${MIN_CODE_LENGTH} characters required.`, 'error');
                return;
            }
            
            if (!connectedAccount) {
                showMessageBox('Please connect your MetaMask wallet before running a backtest that may lead to minting.', 'warning');
                return;
            }

            RUN_BACKTEST_BTN.disabled = true;
            RUN_BACKTEST_BTN.innerHTML = `<svg class="w-5 h-5 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 0014.19 10.64l-2.016-2.02A7.994 7.994 0 004 12c0 4.418 3.582 8 8 8s8-3.582 8-8z"></path></svg> Running Simulation...`;
            BACKTEST_RESULTS_DIV.classList.add('hidden');
            showMessageBox("Backtest initiated. Simulating 1.5 seconds...", 'info');

            setTimeout(() => {
                const results = simulateBacktest(code.length);
                BACKTEST_RESULTS_DIV.innerHTML = renderBacktestResults(results);
                BACKTEST_RESULTS_DIV.classList.remove('hidden');
                
                RUN_BACKTEST_BTN.disabled = false;
                RUN_BACKTEST_BTN.innerHTML = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg> <span>Run Simulated Backtest</span>`;
                showMessageBox(`Backtest complete! P&L: ${results.pnl}%`, 'success');
            }, 1500);
        };
        
        const updateBacktestCodeLength = () => {
            const codeLength = BACKTEST_CODE_INPUT.value.length;
            BACKTEST_CODE_LENGTH_SPAN.textContent = codeLength;
            BACKTEST_CODE_LENGTH_SPAN.classList.remove('text-green-400', 'text-red-400');
            BACKTEST_CODE_LENGTH_SPAN.classList.add(codeLength >= MIN_CODE_LENGTH ? 'text-green-400' : 'text-red-400');
            
            RUN_BACKTEST_BTN.disabled = codeLength < MIN_CODE_LENGTH;
        };
        
        // Signal Feed Core Logic
        const creatorAddresses = [
            '0xCFD3a1b0E7836A3f69595E731F25E4aC78a7fC04', // Minter
            '0xBB8F9A5A4D2B60f9e9f2E9F68c34599a071c53D7', // Other Creator 1
            '0xEEEa7B12C812a3219D3D81D7f93498b83F1fC3A2', // Other Creator 2
            '0x123B5F7D0a831A6B4C4C211244304892c900609D', // Other Creator 3
        ];
        
        const createSignal = () => {
            // 1. Color-coded alerts logic
            const typeOptions = [
                // Red for depegs/liquidations
                { type: 'depeg', color: 'bg-red-600', text: 'DEPEG/LIQ', icon: '🚨', insight: 'High liquidation cascade risk detected on Compound V3.', tag: 'Warning', pnlMin: -0.3, pnlMax: -0.05, sharpeMin: 0.2, sharpeMax: 1.0 },
                // Green for profitable arbitrages
                { type: 'profit', color: 'bg-green-600', text: 'PROFIT ARB', icon: '✅', insight: 'ETH gas dropped 30%, ideal arbitrage window now open.', tag: 'Top', pnlMin: 0.05, pnlMax: 0.3, sharpeMin: 1.8, sharpeMax: 3.5 },
                // Blue for safe updates or gas drops
                { type: 'safe', color: 'bg-blue-600', text: 'SAFE UPDATE', icon: 'ℹ️', insight: 'Minor protocol governance update successful. System is stable.', tag: null, pnlMin: -0.01, pnlMax: 0.05, sharpeMin: 0.8, sharpeMax: 1.8 }
            ];
            
            const strategyNames = ['ETH/DAI Arb', 'USDC/TUSD Swap', 'BTC Futures Gap', 'SOL/DOGE Basis', 'LIDO Staking Yield'];
            
            const chosenType = typeOptions[Math.floor(Math.random() * typeOptions.length)];
            
            // Generate P&L and Sharpe based on the signal type
            const pnl = chosenType.pnlMin + Math.random() * (chosenType.pnlMax - chosenType.pnlMin);
            const sharpe = chosenType.sharpeMin + Math.random() * (chosenType.sharpeMax - chosenType.sharpeMin); 

            // Create volatile sparkline data
            const sparklineData = Array(10).fill(0).map((_, i) => pnl * 10 + Math.sin(i * 0.8) + Math.random() * 0.5);
            
            // Assign a random Creator
            const creator = creatorAddresses[Math.floor(Math.random() * creatorAddresses.length)];

            return {
                id: crypto.randomUUID(),
                strategyName: strategyNames[Math.floor(Math.random() * strategyNames.length)],
                type: chosenType.type,
                typeColor: chosenType.color,
                typeText: chosenType.text,
                typeIcon: chosenType.icon,
                pnl: pnl,
                sharpe: sharpe,
                creatorId: creator, // NEW: Include Creator ID
                timestamp: new Date().toISOString(), 
                codeSnippet: `exec_arb(strategy="${Math.random().toString(36).substring(2, 8)}", amount=1.0, slippage=0.001)`,
                sparklineData: sparklineData,
                tags: ['New', chosenType.tag].filter(Boolean),
                oracleInsight: chosenType.insight,
                isBookmarked: false,
                ttsVoice: VOICE_NAMES[Math.floor(Math.random() * VOICE_NAMES.length)]
            };
        };

        // Inline micro-chart implementation
        const createSparklinePath = (data, width, height) => {
            if (data.length < 2) return '';
            const min = Math.min(...data);
            const max = Math.max(...data);
            const range = max - min;
            const xStep = width / (data.length - 1);

            const scaleX = (i) => i * xStep;
            const scaleY = (value) => {
                if (range === 0) return height / 2;
                // Scale value to 0..1, then invert (SVG Y=0 is top) and scale to height
                return height - (height * ((value - min) / range));
            };

            let path = `M ${scaleX(0)} ${scaleY(data[0])}`;
            for (let i = 1; i < data.length; i++) {
                path += ` L ${scaleX(i)} ${scaleY(data[i])}`;
            }
            return path;
        };

        const renderSparkline = (data) => {
            const width = 80;
            const height = 20;
            const path = createSparklinePath(data, width, height);
            // Color based on overall trend
            const color = data[data.length - 1] > data[0] ? 'var(--pnl-color-pos)' : 'var(--pnl-color-neg)';

            return `
                <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" class="inline-block">
                    <path d="${path}" fill="none" stroke="${color}" stroke-width="1.5" stroke-linejoin="round" stroke-linecap="round"/>
                </svg>
            `;
        };

        const renderSignal = (signal) => {
            const pnlDisplay = (signal.pnl * 100).toFixed(2) + '%';
            const pnlColor = signal.pnl >= 0 ? 'text-green-400' : 'text-red-400';
            
            // Adaptive Sharpe display: Only show when >1.5
            const sharpeRelevant = signal.sharpe >= 1.5;
            const sharpeDisplay = sharpeRelevant ? signal.sharpe.toFixed(2) : '—';
            const sharpeColor = sharpeRelevant ? 'text-cyan-400' : 'text-gray-500';

            // Hover tooltips content
            const tooltipContent = `
                Timestamp: ${new Date(signal.timestamp).toLocaleTimeString()}
                <br>P&L: ${pnlDisplay}
                <br>Sharpe Ratio: ${signal.sharpe.toFixed(2)}
                <br>Strategy: ${signal.strategyName}
            `;

            // Signal bookmarking
            const bookmarkClass = signal.isBookmarked ? 'text-yellow-400' : 'text-gray-600 hover:text-yellow-300';
            
            const isMinterConnected = isMinter(connectedAccount);
            const mintBtnClass = isMinterConnected ? 'bg-gradient-to-r from-cyan-600 to-teal-500' : 'bg-gray-700 cursor-not-allowed';
            const mintBtnAction = isMinterConnected ? `mintStrategy('${signal.id}')` : `showMessageBox('You must be the Minter (${formatAddress(MINTER_ADDRESS)}) to mint.', 'error')`;


            return `
                <div id="signal-${signal.id}" class="signal-item relative p-4 bg-gray-800 rounded-xl shadow-lg border border-gray-700 hover:border-cyan-500/50 transition duration-200">
                    <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between">
                        <!-- Creator ID and Strategy Name (FOR COLLECTORS) -->
                        <div class="flex flex-col space-y-1 mb-2 sm:mb-0">
                            <span class="text-xs font-mono text-gray-400">Creator: <span class="text-purple-400 font-semibold">${formatAddress(signal.creatorId)}</span></span>
                            <div class="text-lg font-bold text-gray-100 tooltip-container cursor-default">
                                ${signal.strategyName}
                                <div class="tooltip-content">${tooltipContent}</div>
                            </div>
                        </div>

                        <!-- Performance Metrics and Interactions -->
                        <div class="flex items-center space-x-4 text-sm w-full sm:w-auto justify-between sm:justify-start">
                             <!-- Color-coded alerts (moved slightly) -->
                            <span class="${signal.typeColor} text-xs font-semibold px-2.5 py-0.5 rounded-full inline-flex items-center justify-center shadow-md flex-shrink-0 min-w-[100px] order-last sm:order-none">
                                ${signal.typeIcon} <span class="ml-1">${signal.typeText}</span>
                            </span>

                            <!-- Inline micro-chart -->
                            <div class="hidden md:block">
                                ${renderSparkline(signal.sparklineData)}
                            </div>

                            <!-- P&L and Adaptive Sharpe Display -->
                            <div class="flex space-x-4">
                                <span class="font-mono ${pnlColor} w-20 text-right font-bold">${pnlDisplay}</span>
                                <span class="font-mono ${sharpeColor} w-16 text-right font-bold">${sharpeDisplay}</span>
                            </div>

                            <!-- Tiny badges -->
                            ${signal.tags.map(tag => {
                                let badgeClass = 'bg-gray-700 text-gray-300';
                                if (tag === 'New') badgeClass = 'bg-cyan-900/50 text-cyan-400';
                                if (tag === 'Top') badgeClass = 'bg-yellow-900/50 text-yellow-400';
                                if (tag === 'Warning') badgeClass = 'bg-red-900/50 text-red-400';
                                return `<span class="hidden sm:inline-block px-2 py-0.5 text-xs font-medium rounded-full ${badgeClass}">${tag}</span>`;
                            }).join('')}

                            <!-- Signal bookmarking -->
                            <button onclick="toggleBookmark('${signal.id}')" class="p-1 rounded ${bookmarkClass}" title="Bookmark Signal">
                                <svg class="w-4 h-4 fill-current" viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                            </button>

                            <!-- Quick mint button -->
                            <button onclick="${mintBtnAction}" class="hidden sm:block px-3 py-1.5 ${mintBtnClass} text-white font-semibold rounded-lg shadow-lg hover:from-cyan-500 hover:to-teal-400 transition-all active:shadow-none active:scale-95 text-xs" title="Mint Strategy Contract (Minter Only)">
                                MINT
                            </button>

                            <!-- One-click copy code -->
                            <button onclick="copyCode('${signal.codeSnippet}')" class="p-1 text-gray-400 hover:text-cyan-400" title="Copy Code Snippet">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2v-2m-2-4l-4 4m0 0l-4-4m4 4V5"></path></svg>
                            </button>
                        </div>
                    </div>

                    <!-- Contextual Hints / Oracle Integration -->
                    <div class="mt-3 flex items-start space-x-2 border-t border-gray-700/50 pt-2">
                        <!-- Ghost persona styling & TTS trigger -->
                        <span id="oracle-ghost-${signal.id}" class="oracle-ghost transition duration-500 cursor-pointer flex-shrink-0" onclick="speakInsight('${signal.oracleInsight}', '${signal.ttsVoice}', 'oracle-ghost-${signal.id}')" title="Hear Oracle Insight (TTS)">
                            👻
                        </span>
                        <!-- Mini insight popover (text display) -->
                        <span class="text-xs text-gray-300 italic">
                            ${signal.oracleInsight}
                        </span>
                    </div>
                </div>
            `;
        };

        // State Management and Actions

        const restoreBookmarks = () => {
            signals = signals.map(s => ({
                ...s,
                isBookmarked: bookmarks[s.id] || false
            }));
        }

        const renderFeed = () => {
            // Sort: Bookmarked first, then by PNL
            const sortedSignals = signals
                .sort((a, b) => b.pnl - a.pnl)
                .sort((a, b) => (b.isBookmarked - a.isBookmarked));

            SIGNAL_FEED.innerHTML = sortedSignals.map(renderSignal).join('');
            
            // Micro-transitions: Remove the 'is-new' class after a delay
            document.querySelectorAll('.is-new').forEach(el => {
                setTimeout(() => el.classList.remove('is-new'), 500);
            });
        };

        const addNewSignal = () => {
            if (signals.length >= MAX_SIGNALS) {
                const nonBookmarkedIndex = signals.findIndex(s => !s.isBookmarked);
                const indexToRemove = nonBookmarkedIndex !== -1 ? nonBookmarkedIndex : signals.length - 1;
                signals.splice(indexToRemove, 1);
            }

            const newSignal = createSignal();
            newSignal.isBookmarked = bookmarks[newSignal.id] || false;
            signals.unshift(newSignal);

            renderFeed();

            const newElement = document.getElementById(`signal-${newSignal.id}`);
            if (newElement) {
                newElement.classList.add('is-new');
            }
        };

        window.toggleBookmark = (id) => {
            const index = signals.findIndex(s => s.id === id);
            if (index !== -1) {
                const isBookmarked = !signals[index].isBookmarked;
                signals[index].isBookmarked = isBookmarked;
                bookmarks[id] = isBookmarked;
                if (!isBookmarked) {
                    delete bookmarks[id];
                }

                localStorage.setItem('signalBookmarks', JSON.stringify(bookmarks));
                renderFeed();
                showMessageBox(isBookmarked ? `Signal ${id.substring(0, 8)} bookmarked.` : `Bookmark removed.`, 'info');
            }
        };

        window.mintStrategy = (id) => {
            if (!connectedAccount) {
                showMessageBox('Wallet not connected. Connect your wallet to attempt minting!', 'error');
                return;
            }
            
            if (!isMinter(connectedAccount)) {
                showMessageBox(`Permission Denied: Only the Minter (${formatAddress(MINTER_ADDRESS)}) can mint.`, 'error');
                return;
            }
            
            // If the user has permission, simulate the transaction logic
            showMessageBox(`MINT Transaction initiated for ${id.substring(0, 8)}. Check MetaMask for authorization...`, 'success');
        };

        window.copyCode = async (codeSnippet) => {
            try {
                if (navigator.clipboard) {
                    await navigator.clipboard.writeText(codeSnippet);
                } else {
                    const textArea = document.createElement("textarea");
                    textArea.value = codeSnippet;
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                }
                showMessageBox('Python-like snippet copied to clipboard!', 'info');
            } catch (err) {
                console.error('Copy failed:', err);
                showMessageBox('Could not copy code. See console for details.', 'error');
            }
        };

        // Stream Control

        const startSignalFeed = () => {
            if (signalTimer) clearInterval(signalTimer);
            signalTimer = setInterval(addNewSignal, REFRESH_INTERVAL);
        };

        const stopSignalFeed = () => {
            if (signalTimer) clearInterval(signalTimer);
        };

        const updateGasTracker = () => {
            const gas = Math.floor(20 + (Math.random() * 25)); // 20 - 45 Gwei
            GAS_TRACKER.textContent = `Gas: ${gas} Gwei`;
            // Color logic: Red > 40, Yellow 30-40, Green < 30
            let color = '#a7f3d0'; // Green
            if (gas > 40) color = '#f87171'; // Red
            else if (gas > 30) color = '#fcd34d'; // Yellow
            
            GAS_TRACKER.style.color = color;
            
            setTimeout(updateGasTracker, 5000);
        };
        
        // Client-Side Routing
        window.showPage = (pageId) => {
            const pages = ['signal-feed-page', 'backtester-page'];
            const navButtons = {
                'signal-feed-page': document.getElementById('nav-feed'),
                'backtester-page': document.getElementById('nav-backtester')
            };

            pages.forEach(id => document.getElementById(id).classList.add('hidden'));
            document.getElementById(pageId).classList.remove('hidden');

            // Update navigation button styles
            Object.keys(navButtons).forEach(key => {
                const btn = navButtons[key];
                btn.classList.remove('text-xl', 'active', 'text-transparent', 'bg-clip-text', 'bg-gradient-to-r', 'from-cyan-400', 'to-teal-500');
                btn.classList.add('text-lg', 'text-gray-400', 'hover:text-white');
                btn.style.borderBottom = 'none';
            });
            
            const activeBtn = navButtons[pageId];
            activeBtn.classList.remove('text-lg', 'text-gray-400', 'hover:text-white');
            activeBtn.classList.add('text-xl', 'active', 'text-transparent', 'bg-clip-text', 'bg-gradient-to-r', 'from-cyan-400', 'to-teal-500');
            activeBtn.style.borderBottom = '3px solid #00bcd4';

            if (pageId === 'signal-feed-page') {
                if (AUTO_REFRESH_TOGGLE.checked) startSignalFeed();
            } else {
                stopSignalFeed();
            }
        };


        // --- Initialization ---

        AUTO_REFRESH_TOGGLE.addEventListener('change', (e) => {
            isRefreshing = e.target.checked;
            if (isRefreshing && document.getElementById('signal-feed-page').classList.contains('hidden') === false) {
                startSignalFeed();
            } else {
                stopSignalFeed();
            }
            showMessageBox(isRefreshing ? 'Real-Time Stream ACTIVATED.' : 'Stream PAUSED.', 'info');
        });
        
        BACKTEST_CODE_INPUT.addEventListener('input', updateBacktestCodeLength);

        window.onload = () => {
            // MetaMask Init
            getInitialState();
            setupListeners();
            
            // DApp Init
            for (let i = 0; i < 5; i++) {
                signals.push(createSignal());
            }
            restoreBookmarks();
            renderFeed();
            
            showPage('signal-feed-page');
            updateGasTracker();
            updateBacktestCodeLength(); 
        };
    </script>
    <script>
        // Placeholder for TTS utility functions (to avoid cluttering the main logic)
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2; // 16-bit PCM

            const buffer = new ArrayBuffer(44 + pcm16.length * bytesPerSample);
            const view = new DataView(buffer);

            let offset = 0;
            // RIFF header
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, 36 + pcm16.length * bytesPerSample, true); offset += 4;
            writeString(view, offset, 'WAVE'); offset += 4;

            // FMT sub-chunk
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4;         
            view.setUint16(offset, 1, true); offset += 2;          // Audio format (1=PCM)
            view.setUint16(offset, numChannels, true); offset += 2; 
            view.setUint32(offset, sampleRate, true); offset += 4;  
            view.setUint32(offset, sampleRate * numChannels * bytesPerSample, true); offset += 4; 
            view.setUint16(offset, numChannels * bytesPerSample, true); offset += 2; 
            view.setUint16(offset, bytesPerSample * 8, true); offset += 2; // Bits per sample

            // DATA sub-chunk
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, pcm16.length * bytesPerSample, true); offset += 4; // Data size

            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }

            return new Blob([view], { type: 'audio/wav' });
        }
        
        window.speakInsight = async function(text, voice, elementId) {
            const oracleIcon = document.getElementById(elementId);
            if (!text || !voice || !oracleIcon) return;

            oracleIcon.classList.add('oracle-ghost-glowing');
            
            const payload = {
                contents: [{
                    parts: [{ text: `Say with a calm, informative tone: ${text}` }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: voice }
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            try {
                const response = await fetchWithRetry(TTS_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    const rateMatch = mimeType.match(/rate=(\d+)/);
                    if (!rateMatch) throw new Error("Could not determine sample rate from MIME type.");
                    const sampleRate = parseInt(rateMatch[1], 10);
                    
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);

                    AUDIO_PLAYER.src = audioUrl;
                    AUDIO_PLAYER.play().catch(e => console.error("Audio playback error:", e));

                    AUDIO_PLAYER.onended = () => {
                        oracleIcon.classList.remove('oracle-ghost-glowing');
                        URL.revokeObjectURL(audioUrl);
                    };
                    return;
                } else {
                    console.error("TTS generation failed or returned unexpected format.", result);
                    showMessageBox("TTS failed to generate audio.", 'error');
                }

            } catch (error) {
                console.error("TTS API call failed:", error);
                showMessageBox("TTS API connection failed.", 'error');
            }
            if (oracleIcon) oracleIcon.classList.remove('oracle-ghost-glowing');
        }
    </script>
</body>
</html>

